% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/odeintr.R
\name{compile_sys}
\alias{compile_sys}
\title{Compile ODE system}
\usage{
compile_sys(name, sys, globals = "", sys_dim = -1L, compile = TRUE, ...)
}
\arguments{
\item{name}{the name of the generated integration function}

\item{sys}{a string containing C++ expressions}

\item{globals}{a string with global C++ declarations}

\item{sys_dim}{length of the state vector}

\item{compile}{if false, just return the code}

\item{...}{passed to \code{\link{sourceCpp}}}
}
\value{
the C++ code invisibly
}
\description{
Generates an integrator using Rcpp
}
\details{
C++ code is generated and compiled with
\code{\link{sourceCpp}}. The returned function will
integrate the system starting from a provided initial
condition and initial time to a specified final time.
An attempt is made to get the length of the state vector
from the system definition. If this fails, the code will
likely crash your R session. It is safer to specify
\code{sys_dim} directly.

The signature of \code{name} is:

\code{name(initial_state, duration, step_size, start)}

where \code{duration} is the integration time, \code{step_size}
is the time step (default = 1.0) and \code{start} is the
starting time (default = 0.0). The
return value from this function is a data frame with time
in the first column and state in the remaining columns.
A \code{name_no_record} function is also generated for
using in benchmarking.

The integration method is a 5th order Dormand-Prince algorithm
with error tolerance (absolute and relative) of 1e-6. The
step size is adaptive. The given step size is tried and a
smaller or larger step size will be used depending on the
esimtated integration error. The time and system state are
recorded after every step. The time increments will generally
be variable.

The C++ expressions must index a state array of length
\code{sys_dim}. The state array is \code{x} and the
derivatives are \code{dxdt}. The first state value is
\code{x[0]} and the first derivative is \code{dxdt[0]}.

In the case you use bare \code{dxdt} and \code{x}, an
attempt will be made to append \code{[0]} to these
variables. This can fail, so do not rely on it. It
requires that \code{dxdt} and \code{x} are adjacent
to a "non-word" character as defined by perl regular
expressions. This will also fail if you set \code{sys_dim}
to a positive value.

The \code{globals} string can be arbitrary C++ code. You
can set global named parameter values here, or you could
specify exported Rcpp functions for manipulating or recording
state.
}
\note{
The c++11 plugin is enabled.

Also, despite using an array as the state,
even when it is length one, there is no performance penalty as the length
of the state vector is known at compile time. Your compiler will optimize
out any pointer dereferencing. You may get a large increase in performance
by enabling function inlining and loop unrolling. For GCC, that is "-O3". Chances
are that your R distribution uses "-O2". You can override this by copying each
line containing "-O2" from your R distribution's Makeconf to .R/Makevars in
your home directory replacing each instance of "-O2" with "-O3". You might
be able to do this with environment variables. I have not been able to
verify whether that works. You might also try \code{\link{set_optimization}}.
}
\examples{
\dontrun{
# Logistic growth
compile_sys("logistic", "dxdt = x * (1 - x)")
plot(logistic(0.001, 15), type = "l", lwd = 2)
Sys.sleep(0.5)

# Lotka-Volterra predator-prey equations
LV.sys = '
  dxdt[0] = x[0] - 0.1 * x[0] * x[1];
  dxdt[1] = 0.05 * x[0] * x[1] - 0.5 * x[1];
' # LV.sys
compile_sys("preypred", LV.sys)
system.time(preypred_no_record(rep(1, 2), 1e6))
x = preypred(rep(1, 2), 100)
plot(x[, 2:3], type = "l", xlab = "Prey", ylab = "Predator")
Sys.sleep(0.5)

# Lorenz model from odeint examples
Lorenz.globals = '
  const double sigma_ = 10.0;
  const double R_ = 28.0;
  const double b_ = 8.0 / 3.0;
' # Lorenz.globals
Lorenz.sys = '
  dxdt[0] = sigma_ * (x[1] - x[0]);
  dxdt[1] = R_ * x[0] - x[1] - x[0] * x[2];
  dxdt[2] = -b_ * x[2] + x[0] * x[1];
' # Lorenz.sys
compile_sys("lorenz", Lorenz.sys, Lorenz.globals)
system.time(lorenz_no_record(rep(1, 3), 1e5))
x = lorenz(rep(1, 3), 100)
plot(x[, c(2, 4)], type = 'l')
}
}
\author{
Timothy H. Keitt
}
\seealso{
\code{\link{set_optimization}}, \code{\link{integrate_sys}}
}

